<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éŸ³é¢‘åŠ å¯†è§£å¯†å·¥å…· v3.1</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }
        
        .section {
            background-color: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h2 {
            color: #3498db;
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input[type="text"],
        input[type="file"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        button {
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button.secondary {
            background-color: #95a5a6;
        }
        
        button.secondary:hover {
            background-color: #7f8c8d;
        }
        
        button.danger {
            background-color: #e74c3c;
        }
        
        button.danger:hover {
            background-color: #c0392b;
        }
        
        #key-display {
            background-color: #ecf0f1;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            margin-bottom: 15px;
            word-break: break-all;
        }
        
        #file-info {
            background-color: #e8f4f8;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        
        #progress {
            width: 100%;
            height: 20px;
            background-color: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        #progress-bar {
            height: 100%;
            background-color: #2ecc71;
            width: 0%;
            transition: width 0.3s;
        }
        
        .audio-player {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        
        audio {
            width: 100%;
            margin-top: 10px;
        }
        
        .file-list {
            margin-top: 15px;
        }
        
        .file-item {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .file-item button {
            padding: 5px 10px;
            font-size: 14px;
        }
        
        .error {
            color: #e74c3c;
            margin-top: 10px;
        }
        
        .success {
            color: #2ecc71;
            margin-top: 10px;
        }
        
        /* é«˜çº§æ’­æ”¾å™¨æ ·å¼ */
        .advanced-player {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 30px;
            color: white;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }
        
        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        
        .player-title {
            font-size: 24px;
            font-weight: bold;
        }
        
        .settings-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            font-size: 20px;
        }
        
        .settings-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: rotate(30deg);
        }
        
        .album-art {
            width: 200px;
            height: 200px;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            margin: 0 auto 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }
        
        .song-info {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .song-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .song-artist {
            font-size: 16px;
            opacity: 0.8;
            margin-bottom: 4px;
        }
        
        .song-album {
            font-size: 14px;
            opacity: 0.6;
        }
        
        .player-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            font-size: 20px;
        }
        
        .control-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }
        
        .control-btn.play-btn {
            width: 70px;
            height: 70px;
            background: white;
            color: #667eea;
            font-size: 24px;
        }
        
        .control-btn.play-btn:hover {
            transform: scale(1.1);
        }
        
        .progress-container {
            margin-bottom: 20px;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            cursor: pointer;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: white;
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .time-display {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            opacity: 0.8;
            margin-top: 8px;
        }
        
        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .volume-slider {
            flex: 1;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            cursor: pointer;
            overflow: hidden;
            position: relative;
        }
        
        .volume-fill {
            height: 100%;
            background: white;
            width: 80%;
            border-radius: 2px;
        }
        
        .volume-handle {
            position: absolute;
            top: 50%;
            right: -6px;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.2s;
        }
        
        .volume-handle:hover {
            transform: translateY(-50%) scale(1.2);
        }
        
        #volume-level {
            font-size: 12px;
            min-width: 40px;
            text-align: right;
            opacity: 0.8;
        }
        
        /* æ¨¡å¼åˆ‡æ¢æŒ‰é’® */
        .mode-switch {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        .switch-btn {
            padding: 10px 20px;
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            margin: 0 5px;
        }
        
        .switch-btn.active {
            background: white;
            color: #667eea;
        }
        
        /* è®¾ç½®é¢æ¿ */
        .settings-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            display: none;
        }
        
        .settings-panel.show {
            display: block;
        }
        
        .settings-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
        }
        
        .setting-item {
            margin-bottom: 15px;
        }
        
        .setting-label {
            display: block;
            font-weight: bold;
            color: #555;
            margin-bottom: 8px;
        }
        
        .setting-value {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            word-break: break-all;
            color: #333;
        }
        
        /* ä¸€é”®åŠ è§£å¯†æŒ‰é’® */
        .quick-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .quick-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .quick-btn.encrypt {
            background: #2ecc71;
            color: white;
        }
        
        .quick-btn.decrypt {
            background: #3498db;
            color: white;
        }
        
        .quick-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        /* å¼€å…³æ ·å¼ */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #3498db;
        }
        
        input:focus + .slider {
            box-shadow: 0 0 1px #3498db;
        }
        
        input:checked + .slider:before {
            transform: translateX(26px);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>éŸ³é¢‘åŠ å¯†è§£å¯†å·¥å…· v3.1</h1>
        
        <!-- è®¾å¤‡ç å’Œå¯†é’¥ç”Ÿæˆ (éšè—) -->
        <div class="section" style="display: none;">
            <h2>1. è®¾å¤‡ç ä¸å¯†é’¥ç®¡ç†</h2>
            <div class="form-group">
                <label for="device-code">è®¾å¤‡ç :</label>
                <input type="text" id="device-code" placeholder="è¾“å…¥æˆ–ç”Ÿæˆè®¾å¤‡ç ">
            </div>
            <div class="btn-group">
                <button onclick="generateDeviceCode()">ç”Ÿæˆè®¾å¤‡ç </button>
                <button onclick="generateKey()">ç”Ÿæˆå¯†é’¥</button>
            </div>
            <div id="key-display">å¯†é’¥å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</div>
        </div>
        
        <!-- éŸ³é¢‘æ–‡ä»¶å¤„ç† -->
        <div class="section">
            <h2>1. éŸ³é¢‘æ–‡ä»¶å¤„ç†</h2>
            <div class="form-group">
                <label for="audio-file">é€‰æ‹©éŸ³é¢‘æ–‡ä»¶ (æœ€å¤§250MB):</label>
                <input type="file" id="audio-file" accept=".mp3,.flac,.wav,.smp3,.sflac,.lgg,.lav" multiple>
            </div>
            <div class="form-group">
                <label for="folder-upload">æˆ–é€‰æ‹©æ–‡ä»¶å¤¹:</label>
                <input type="file" id="folder-upload" webkitdirectory mozdirectory directory accept=".mp3,.flac,.wav,.smp3,.sflac,.lgg,.lav">
            </div>
            <div class="btn-group">
                <button onclick="encryptAudio()">åŠ å¯†</button>
                <button onclick="decryptAudio()">è§£å¯†</button>
                <button onclick="oneClickDecrypt()">ä¸€é”®è§£å¯†</button>
                <button onclick="manualScan()">æ‰‹åŠ¨æ‰«æå¯¼å…¥</button>
                <button onclick="uploadFolder()">ä¸Šä¼ æ–‡ä»¶å¤¹å¯¼å…¥</button>
            </div>
            <div id="progress">
                <div id="progress-bar"></div>
            </div>
            <div id="message"></div>
            <div style="margin-top: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h3>æ­Œæ›²åˆ—è¡¨</h3>
                    <div class="btn-group">
                        <button onclick="playAllSongs()">æ’­æ”¾å…¨éƒ¨</button>
                        <button onclick="clearSongList()">æ¸…ç©ºåˆ—è¡¨</button>
                    </div>
                </div>
                <div id="song-library" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
                    <p>æš‚æ— æ­Œæ›²ï¼Œç‚¹å‡»"æ‰‹åŠ¨æ‰«æå¯¼å…¥"æˆ–"ä¸Šä¼ æ–‡ä»¶å¤¹å¯¼å…¥"æ·»åŠ æ­Œæ›²</p>
                </div>
                <div style="margin-top: 10px;">
                    <h4>å½“å‰æ’­æ”¾</h4>
                    <div id="current-playing" style="background: #f8f9fa; padding: 10px; border-radius: 4px; border-left: 4px solid #3498db;">
                        <p>æš‚æ— æ’­æ”¾å†…å®¹</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- éŸ³é¢‘æ’­æ”¾å™¨ -->
        <div class="section">
            <h2>2. éŸ³é¢‘æ’­æ”¾</h2>
            
            <!-- é«˜çº§æ’­æ”¾å™¨ -->
            <div id="advanced-player" class="advanced-player">
                <div class="player-header">
                    <div class="player-title">éŸ³ä¹æ’­æ”¾å™¨</div>
                    <button class="settings-btn" onclick="toggleSettings()">âš™ï¸</button>
                </div>
                
                <div class="album-art">ğŸµ</div>
                
                <div class="song-info">
                    <div class="song-title" id="advanced-title">æœªé€‰æ‹©æ­Œæ›²</div>
                    <div class="song-artist" id="advanced-artist">æœªçŸ¥è‰ºæœ¯å®¶</div>
                    <div class="song-album" id="advanced-album">æœªçŸ¥ä¸“è¾‘</div>
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar" onclick="seekAudio(event)">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <div class="time-display">
                        <span id="current-time">0:00</span>
                        <span id="total-time">0:00</span>
                    </div>
                </div>
                
                <div class="player-controls">
                    <button class="control-btn" onclick="loadEncryptedAudio()">ğŸ“</button>
                    <button class="control-btn" onclick="audioPlayer.currentTime -= 10">âª</button>
                    <button class="control-btn play-btn" id="advanced-play-btn" onclick="togglePlay()">â–¶ï¸</button>
                    <button class="control-btn" onclick="audioPlayer.currentTime += 10">â©</button>

                </div>
                
                <div class="volume-control">
                    <span>ğŸ”Š</span>
                    <div class="volume-slider" onclick="setVolume(event)" onmousedown="startVolumeDrag(event)">
                        <div class="volume-fill" id="volume-fill"></div>
                        <div class="volume-handle" id="volume-handle"></div>
                    </div>
                    <span id="volume-level">80%</span>
                    <span>ğŸ”‡</span>
                </div>
                
                <div id="decrypt-status-advanced" style="margin-top: 20px; opacity: 0.8;"></div>
                
                <!-- ä¸€é”®æ“ä½œ -->
                <div class="quick-actions">
                    <button class="quick-btn encrypt" onclick="quickEncrypt()">ğŸ”’ ä¸€é”®åŠ å¯†</button>
                    <button class="quick-btn decrypt" onclick="quickDecrypt()">ğŸ”“ ä¸€é”®è§£å¯†</button>
                    <button class="quick-btn" style="background: #2ecc71; color: white;" onclick="oneClickScan()">ğŸ“ ä¸€é”®æ‰«æå¯¼å…¥</button>
                </div>
                
                <!-- è®¾ç½®é¢æ¿ -->
                <div id="settings-panel" class="settings-panel">
                    <div class="settings-title">è®¾ç½®</div>
                    
                    <div class="setting-item">
                        <div class="setting-label">è®¾å¤‡ç </div>
                        <input type="text" id="advanced-device-code" placeholder="è¾“å…¥æˆ–ç”Ÿæˆè®¾å¤‡ç " style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <button onclick="generateDeviceCodeAdvanced()" style="flex: 1; padding: 8px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer;">ç”Ÿæˆè®¾å¤‡ç </button>
                            <button onclick="generateKeyAdvanced()" style="flex: 1; padding: 8px; background: #2ecc71; color: white; border: none; border-radius: 4px; cursor: pointer;">ç”Ÿæˆå¯†é’¥</button>
                        </div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">å½“å‰å¯†é’¥</div>
                        <div class="setting-value" id="advanced-key-display">å¯†é’¥å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">è‡ªåŠ¨è§£å¯†çŠ¶æ€</div>
                        <div class="setting-value" id="advanced-auto-decrypt-status">å·²å…³é—­</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">éŸ³é¢‘åŠ å¯†ä¿æŠ¤</div>
                        <div style="display: flex; align-items: center;">
                            <label class="switch">
                                <input type="checkbox" id="encryption-protection-switch" checked>
                                <span class="slider round"></span>
                            </label>
                            <span style="margin-left: 10px;" id="encryption-protection-status">å·²å¼€å¯</span>
                        </div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">å¯†é’¥ç®¡ç†</div>
                        <div class="btn-group" style="margin-bottom: 15px; display: flex; gap: 10px;">
                            <button onclick="regenerateAllKeys()" style="padding: 10px 20px; background: #e74c3c; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; transition: background-color 0.2s;">é‡æ–°ç”Ÿæˆ5ä¸ªå¯†é’¥</button>
                            <button onclick="saveCurrentKey()" style="padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; transition: background-color 0.2s;">ä¸€é”®ä¿å­˜å½“å‰å¯†é’¥</button>
                        </div>
                        
                        <!-- è‡ªä¸»æ·»åŠ å¯†é’¥åŠŸèƒ½ -->
                        <div style="margin-bottom: 15px; display: flex; gap: 10px; align-items: stretch;">
                            <input type="text" id="new-key-input" placeholder="è¾“å…¥32ä½åå…­è¿›åˆ¶å¯†é’¥" style="flex: 1; padding: 10px; border: 1px solid #dee2e6; border-radius: 6px; font-family: monospace; font-size: 14px; color: #333; background: white; box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); transition: border-color 0.2s;">
                            <button onclick="addKey()" style="padding: 10px 20px; background: #2ecc71; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; transition: background-color 0.2s;">æ·»åŠ å¯†é’¥</button>
                        </div>
                        
                        <div style="margin-bottom: 10px; font-size: 14px; font-weight: bold; color: #495057;">
                            å¯†é’¥åˆ—è¡¨
                        </div>
                        <div id="key-list" style="max-height: 400px; overflow-y: auto; padding: 15px; background: white; border: 1px solid #e9ecef; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.05);">
                            <!-- å¯†é’¥åˆ—è¡¨å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- å¹³å°æ ¼å¼è§£å¯† -->
        <div class="section">
            <h2>3. å¹³å°æ ¼å¼è§£å¯†</h2>
            <div style="background: #f8f9fa; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                <p style="margin-bottom: 15px; color: #555;">ç›´æ¥ä½¿ç”¨å†…ç½®çš„Unlock Musicå·¥å…·è§£å¯†éŸ³ä¹æ–‡ä»¶ï¼Œæ”¯æŒå¤šç§å¹³å°æ ¼å¼ã€‚</p>
                <iframe src="https://um-react.netlify.app/" style="width: 100%; height: 600px; border: none; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);" title="Unlock Music - éŸ³ä¹è§£é”å·¥å…·"></iframe>
            </div>
        </div>
        
        <!-- å¤„ç†åçš„æ–‡ä»¶åˆ—è¡¨ -->
        <div class="section">
            <h2>4. å¤„ç†åçš„æ–‡ä»¶</h2>
            <div style="margin-bottom: 15px; display: flex; gap: 10px;">
                <button onclick="clearFileList()" class="secondary">æ¸…é™¤è®°å½•</button>
                <button onclick="batchDownloadFiles()">æ‰¹é‡ä¸‹è½½</button>
            </div>
            <div id="file-list" class="file-list"></div>
        </div>
    </div>
    
    <!-- éŸ³é¢‘æ’­æ”¾å™¨å…ƒç´ ï¼ˆéšè—ï¼‰ -->
    <audio id="audio-player" style="display: none;"></audio>
    
    <script>
        // å…¨å±€å˜é‡
        let currentKey = localStorage.getItem('audioEncryptorKey'); // ä»localStorageåŠ è½½å¯†é’¥
        let currentFile = null;
        let decryptedAudioBuffer = null;
        const isAutoDecryptEnabled = true; // è‡ªåŠ¨è§£å¯†åŠŸèƒ½å§‹ç»ˆå¼€å¯ï¼Œä¸å¯ä¿®æ”¹
        let isEncryptionProtectionEnabled = localStorage.getItem('isEncryptionProtectionEnabled') === 'true' || true; // ä»localStorageåŠ è½½çŠ¶æ€ï¼Œé»˜è®¤å¼€å¯
        let decryptQueue = [];
        let isDecrypting = false;
        let processedFiles = []; // ä¿å­˜å¤„ç†åçš„æ–‡ä»¶åˆ—è¡¨ï¼Œç”¨äºæ‰¹é‡ä¸‹è½½
        
        // å¹³å°æ ¼å¼è§£å¯†ç›¸å…³å˜é‡
        let platformDecryptedFiles = [];
        let concurrentDecryptCount = 0;
        const MAX_CONCURRENT_DECRYPT = 3; // æœ€å¤§å¹¶å‘è§£å¯†æ•°
        let decryptProgress = { total: 0, completed: 0 };
        
        // ç”Ÿæˆè®¾å¤‡ç 
        function generateDeviceCode() {
            const deviceCode = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
            document.getElementById('device-code').value = deviceCode;
        }
        
        // æ ¹æ®è®¾å¤‡ç ç”Ÿæˆå¯†é’¥
        async function generateKey() {
            const deviceCode = document.getElementById('device-code').value;
            if (!deviceCode) {
                showMessage('è¯·å…ˆè¾“å…¥è®¾å¤‡ç ', 'error');
                return;
            }
            
            // ä½¿ç”¨SHA-256ç”Ÿæˆå¯†é’¥
            const encoder = new TextEncoder();
            const data = encoder.encode(deviceCode);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const keyHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            
            // æˆªå–å‰32å­—èŠ‚ä½œä¸ºAESå¯†é’¥
            currentKey = keyHex.substring(0, 32);
            document.getElementById('key-display').textContent = `å¯†é’¥: ${currentKey}`;
            
            // ä¿å­˜å¯†é’¥åˆ°localStorage
            localStorage.setItem('audioEncryptorKey', currentKey);
            
            showMessage('å¯†é’¥ç”ŸæˆæˆåŠŸï¼Œå·²ä¿å­˜åˆ°æœ¬åœ°ï¼Œä¸‹æ¬¡æ— éœ€é‡æ–°ç”Ÿæˆ', 'success');
        }
        
        // æ˜¾ç¤ºæ¶ˆæ¯
        function showMessage(message, type = 'info') {
            const messageDiv = document.getElementById('message');
            messageDiv.textContent = message;
            messageDiv.className = type;
        }
        
        // æ›´æ–°è¿›åº¦æ¡
        function updateProgress(progress) {
            const progressBar = document.getElementById('progress-bar');
            progressBar.style.width = `${progress}%`;
        }
        
        // å¤„ç†æ–‡ä»¶é€‰æ‹©ï¼ˆç¬¬1éƒ¨åˆ†ï¼‰
        document.getElementById('audio-file').addEventListener('change', async function(e) {
            const files = Array.from(e.target.files);
            if (files.length > 0) {
                const file = files[0];
                // æ£€æŸ¥æ–‡ä»¶å¤§å° (250MB)
                if (file.size > 250 * 1024 * 1024) {
                    showMessage('æ–‡ä»¶å¤§å°è¶…è¿‡250MBé™åˆ¶', 'error');
                    return;
                }
                
                currentFile = file;
                const fileInfo = `æ–‡ä»¶å: ${file.name}<br>æ–‡ä»¶å¤§å°: ${(file.size / (1024 * 1024)).toFixed(2)} MB<br>ç±»å‹: ${file.type}`;
                document.getElementById('file-info').innerHTML = fileInfo;
                showMessage('æ–‡ä»¶å·²é€‰æ‹©', 'success');
                
                // åŒæ­¥åˆ°æ’­æ”¾å™¨ï¼ˆç¬¬2éƒ¨åˆ†ï¼‰
                updatePlayerInfo(file.name, 'æœªçŸ¥è‰ºæœ¯å®¶', 'æœªçŸ¥ä¸“è¾‘');
                showPlayStatus('ready');
                
                // ç›´æ¥ä¸ºæ’­æ”¾å™¨åŠ è½½æ–‡ä»¶
                try {
                    const audioPlayer = document.getElementById('audio-player');
                    // æ£€æŸ¥æ˜¯å¦ä¸ºåŠ å¯†æ–‡ä»¶
                    const fileExtension = file.name.split('.').pop().toLowerCase();
                    const isEncrypted = ['.smp3', '.sflac', '.lgg', '.lav'].includes('.' + fileExtension);
                    
                    let url;
                    if (isEncrypted) {
                        // å¦‚æœæ˜¯åŠ å¯†æ–‡ä»¶ï¼Œæš‚æ—¶ä¸è‡ªåŠ¨è§£å¯†ï¼Œåªæ›´æ–°ä¿¡æ¯
                        url = null;
                    } else {
                        // éåŠ å¯†æ–‡ä»¶ï¼Œç›´æ¥åˆ›å»ºURL
                        url = URL.createObjectURL(file);
                        audioPlayer.src = url;
                    }
                } catch (error) {
                    console.error('åŒæ­¥æ–‡ä»¶åˆ°æ’­æ”¾å™¨å¤±è´¥:', error);
                }
            }
        });
        
        // å®ç°æ–‡ä»¶å¤¹ä¸Šä¼ çš„æ–‡ä»¶é€‰æ‹©åŒæ­¥
        document.getElementById('folder-upload').addEventListener('change', async function(e) {
            const files = Array.from(e.target.files);
            if (files.length > 0) {
                // åªåŒæ­¥ç¬¬ä¸€ä¸ªæ–‡ä»¶åˆ°æ’­æ”¾å™¨
                const file = files[0];
                currentFile = file;
                const fileInfo = `æ–‡ä»¶å¤¹: ${file.webkitRelativePath.split('/')[0]}<br>å…± ${files.length} ä¸ªæ–‡ä»¶`;
                document.getElementById('file-info').innerHTML = fileInfo;
                showMessage(`å·²é€‰æ‹©æ–‡ä»¶å¤¹ï¼Œå…± ${files.length} ä¸ªæ–‡ä»¶`, 'success');
                
                // åŒæ­¥åˆ°æ’­æ”¾å™¨ï¼ˆç¬¬2éƒ¨åˆ†ï¼‰
                updatePlayerInfo(file.name, 'æœªçŸ¥è‰ºæœ¯å®¶', file.webkitRelativePath.split('/')[0]);
                showPlayStatus('ready');
                
                // ç›´æ¥ä¸ºæ’­æ”¾å™¨åŠ è½½ç¬¬ä¸€ä¸ªæ–‡ä»¶
                try {
                    const audioPlayer = document.getElementById('audio-player');
                    // æ£€æŸ¥æ˜¯å¦ä¸ºåŠ å¯†æ–‡ä»¶
                    const fileExtension = file.name.split('.').pop().toLowerCase();
                    const isEncrypted = ['.smp3', '.sflac', '.lgg', '.lav'].includes('.' + fileExtension);
                    
                    let url;
                    if (isEncrypted) {
                        // å¦‚æœæ˜¯åŠ å¯†æ–‡ä»¶ï¼Œæš‚æ—¶ä¸è‡ªåŠ¨è§£å¯†ï¼Œåªæ›´æ–°ä¿¡æ¯
                        url = null;
                    } else {
                        // éåŠ å¯†æ–‡ä»¶ï¼Œç›´æ¥åˆ›å»ºURL
                        url = URL.createObjectURL(file);
                        audioPlayer.src = url;
                    }
                } catch (error) {
                    console.error('åŒæ­¥æ–‡ä»¶å¤¹æ–‡ä»¶åˆ°æ’­æ”¾å™¨å¤±è´¥:', error);
                }
            }
        });
        
        // åŠ å¯†éŸ³é¢‘
        async function encryptAudio() {
            if (!isEncryptionProtectionEnabled) {
                showMessage('éŸ³é¢‘åŠ å¯†ä¿æŠ¤åŠŸèƒ½å·²å…³é—­ï¼Œæ— æ³•è¿›è¡ŒåŠ å¯†æ“ä½œ', 'error');
                return;
            }
            if (!currentKey) {
                showMessage('è¯·å…ˆç”Ÿæˆå¯†é’¥', 'error');
                return;
            }
            if (!currentFile) {
                showMessage('è¯·å…ˆé€‰æ‹©éŸ³é¢‘æ–‡ä»¶', 'error');
                return;
            }
            
            showMessage('å¼€å§‹åŠ å¯†...');
            // æ›´æ–°æ’­æ”¾å™¨åŠ å¯†çŠ¶æ€
            showPlayStatus('encrypting');
            updateProgress(0);
            
            try {
                const arrayBuffer = await currentFile.arrayBuffer();
                updateProgress(20);
                
                // é€‰æ‹©åŠ å¯†æ ¼å¼
                const fileExtension = currentFile.name.split('.').pop().toLowerCase();
                let encryptedFormat = 'smp3'; // é»˜è®¤æ ¼å¼
                
                if (fileExtension === 'flac') {
                    encryptedFormat = 'sflac';
                } else if (fileExtension === 'mp3') {
                    encryptedFormat = 'smp3';
                }
                
                // åŠ å¯†æ•°æ®
                const encryptedData = await encryptData(arrayBuffer, currentKey);
                updateProgress(80);
                
                // åˆ›å»ºåŠ å¯†æ–‡ä»¶
                const encryptedFileName = currentFile.name.replace(/\.[^/.]+$/, '') + '.' + encryptedFormat;
                const blob = new Blob([encryptedData], { type: 'application/octet-stream' });
                
                // æ·»åŠ åˆ°æ–‡ä»¶åˆ—è¡¨
                addFileToList(encryptedFileName, blob);
                
                updateProgress(100);
                showMessage('éŸ³é¢‘åŠ å¯†æˆåŠŸ', 'success');
                // æ›´æ–°æ’­æ”¾å™¨çŠ¶æ€ä¸ºå‡†å¤‡å°±ç»ª
                showPlayStatus('ready');
            } catch (error) {
                console.error('åŠ å¯†é”™è¯¯:', error);
                showMessage('åŠ å¯†å¤±è´¥: ' + error.message, 'error');
                // æ›´æ–°æ’­æ”¾å™¨çŠ¶æ€ä¸ºå‡†å¤‡å°±ç»ª
                showPlayStatus('ready');
            }
        }
        
        // è§£å¯†éŸ³é¢‘
        async function decryptAudio() {
            if (!isEncryptionProtectionEnabled) {
                showMessage('éŸ³é¢‘åŠ å¯†ä¿æŠ¤åŠŸèƒ½å·²å…³é—­ï¼Œæ— æ³•è¿›è¡Œè§£å¯†æ“ä½œ', 'error');
                return;
            }
            if (!currentFile) {
                showMessage('è¯·å…ˆé€‰æ‹©éŸ³é¢‘æ–‡ä»¶', 'error');
                return;
            }
            
            showMessage('å¼€å§‹è§£å¯†...');
            // æ›´æ–°æ’­æ”¾å™¨è§£å¯†çŠ¶æ€
            showPlayStatus('decrypting');
            updateProgress(0);
            
            try {
                const arrayBuffer = await currentFile.arrayBuffer();
                updateProgress(20);
                
                // æ£€æµ‹æ–‡ä»¶ç±»å‹
                const fileType = detectFileType(currentFile.name, arrayBuffer);
                
                // å…¶ä»–åŠ å¯†æ ¼å¼æ”¯æŒï¼ˆæ˜¾ç¤ºä¿¡æ¯ï¼‰
                if (fileType.type !== 'aes') {
                    showMessage(`å·²è¯†åˆ«åˆ°${getFormatName(fileType)}æ ¼å¼ï¼Œè¯¥æ ¼å¼æ”¯æŒæ­£åœ¨å¼€å‘ä¸­...`, 'info');
                    updateProgress(100);
                    // æ›´æ–°æ’­æ”¾å™¨çŠ¶æ€ä¸ºå‡†å¤‡å°±ç»ª
                    showPlayStatus('ready');
                    return;
                }
                
                // ä½¿ç”¨åŸæœ‰AESè§£å¯†æˆ–è‡ªåŠ¨åŒ¹é…å¯†é’¥
                let decryptedData;
                let usedKey;
                
                try {
                    // é¦–å…ˆå°è¯•å½“å‰å¯†é’¥ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                    if (currentKey) {
                        decryptedData = await decryptData(arrayBuffer, currentKey);
                        usedKey = currentKey;
                        showMessage(`ä½¿ç”¨å½“å‰å¯†é’¥è§£å¯†æˆåŠŸ`, 'success');
                    } else {
                        // å½“å‰å¯†é’¥ä¸å­˜åœ¨ï¼Œå°è¯•è‡ªåŠ¨åŒ¹é…
                        const result = await autoMatchKeyAndDecrypt(currentFile, arrayBuffer);
                        decryptedData = result.decryptedData;
                        usedKey = result.key;
                        showMessage(`è‡ªåŠ¨åŒ¹é…å¯†é’¥æˆåŠŸï¼Œä½¿ç”¨å¯†é’¥: ${usedKey.substring(0, 8)}...`, 'success');
                    }
                } catch (error) {
                    // å½“å‰å¯†é’¥è§£å¯†å¤±è´¥ï¼Œå°è¯•è‡ªåŠ¨åŒ¹é…
                    try {
                        const result = await autoMatchKeyAndDecrypt(currentFile, arrayBuffer);
                        decryptedData = result.decryptedData;
                        usedKey = result.key;
                        showMessage(`å½“å‰å¯†é’¥è§£å¯†å¤±è´¥ï¼Œè‡ªåŠ¨åŒ¹é…å¯†é’¥æˆåŠŸï¼Œä½¿ç”¨å¯†é’¥: ${usedKey.substring(0, 8)}...`, 'success');
                    } catch (autoMatchError) {
                        // è‡ªåŠ¨åŒ¹é…ä¹Ÿå¤±è´¥
                        throw autoMatchError;
                    }
                }
                updateProgress(80);
                
                // ç¡®å®šåŸå§‹æ–‡ä»¶æ ¼å¼
                const fileExtension = currentFile.name.split('.').pop().toLowerCase();
                let originalFormat = 'mp3';
                
                if (fileExtension === 'sflac') {
                    originalFormat = 'flac';
                } else if (fileExtension === 'smp3') {
                    originalFormat = 'mp3';
                } else if (fileExtension === 'lgg' || fileExtension === 'lav') {
                    originalFormat = 'wav'; // é»˜è®¤æ ¼å¼
                }
                
                // åˆ›å»ºè§£å¯†æ–‡ä»¶
                // è§£æåŸå§‹æ–‡ä»¶åè·å–æ­Œæ›²ä¿¡æ¯
                const originalFileName = currentFile.name.replace(/\.[^/.]+$/, '');
                let title = originalFileName;
                let artist = '';
                
                // å°è¯•ä»æ–‡ä»¶åä¸­æå–è‰ºæœ¯å®¶å’Œæ ‡é¢˜
                const pattern = /^(.*?)\s*[-_]\s*(.*?)$/;
                const match = originalFileName.match(pattern);
                if (match && match[1] && match[2]) {
                    artist = match[1].trim() + ' - ';
                    title = match[2].trim();
                }
                
                // ç”Ÿæˆå‹å¥½çš„è§£å¯†æ–‡ä»¶å
                const decryptedFileName = artist + title + '.' + originalFormat;
                const blob = new Blob([decryptedData], { type: `audio/${originalFormat}` });
                
                // æ·»åŠ åˆ°æ–‡ä»¶åˆ—è¡¨
                addFileToList(decryptedFileName, blob);
                
                updateProgress(100);
                showMessage('éŸ³é¢‘è§£å¯†æˆåŠŸ', 'success');
                // æ›´æ–°æ’­æ”¾å™¨çŠ¶æ€ä¸ºå‡†å¤‡å°±ç»ª
                showPlayStatus('ready');
            } catch (error) {
                console.error('è§£å¯†é”™è¯¯:', error);
                showMessage('è§£å¯†å¤±è´¥: ' + error.message, 'error');
                // æ›´æ–°æ’­æ”¾å™¨çŠ¶æ€ä¸ºå‡†å¤‡å°±ç»ª
                showPlayStatus('ready');
            }
        }
        
        // ä¸€é”®è§£å¯†åŠŸèƒ½
        async function oneClickDecrypt() {
            const fileInput = document.getElementById('audio-file');
            const folderInput = document.getElementById('folder-upload');
            
            let files = [];
            
            // è·å–é€‰æ‹©çš„æ–‡ä»¶
            if (fileInput.files.length > 0) {
                files = Array.from(fileInput.files);
            } else if (folderInput.files.length > 0) {
                files = Array.from(folderInput.files);
            } else if (currentFile) {
                // å¦‚æœæ²¡æœ‰é€šè¿‡æ–‡ä»¶è¾“å…¥é€‰æ‹©æ–‡ä»¶ï¼Œä½†currentFileå­˜åœ¨ï¼ˆä¾‹å¦‚ä»æ’­æ”¾å™¨é€‰æ‹©çš„æ–‡ä»¶ï¼‰
                files = [currentFile];
            }
            
            if (files.length === 0) {
                showMessage('è¯·å…ˆé€‰æ‹©è¦è§£å¯†çš„æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹', 'error');
                return;
            }
            
            if (!isEncryptionProtectionEnabled) {
                showMessage('éŸ³é¢‘åŠ å¯†ä¿æŠ¤åŠŸèƒ½å·²å…³é—­ï¼Œæ— æ³•è¿›è¡Œè§£å¯†æ“ä½œ', 'error');
                return;
            }
            
            showMessage(`å¼€å§‹ä¸€é”®è§£å¯† ${files.length} ä¸ªæ–‡ä»¶...`);
            updateProgress(0);
            
            let successCount = 0;
            let failCount = 0;
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const progress = Math.round((i / files.length) * 100);
                updateProgress(progress);
                
                try {
                    showMessage(`æ­£åœ¨è§£å¯†ç¬¬ ${i + 1}/${files.length} ä¸ªæ–‡ä»¶: ${file.name}`);
                    
                    const arrayBuffer = await file.arrayBuffer();
                    
                    // æ£€æµ‹æ–‡ä»¶ç±»å‹
                    const fileType = detectFileType(file.name, arrayBuffer);
                    
                    // åªå¤„ç†AESåŠ å¯†æ ¼å¼
                    if (fileType.type !== 'aes') {
                        showMessage(`è·³è¿‡éAESæ ¼å¼æ–‡ä»¶: ${file.name}`, 'info');
                        failCount++;
                        continue;
                    }
                    
                    // ä½¿ç”¨è‡ªåŠ¨åŒ¹é…å¯†é’¥è§£å¯†
                    let decryptedData;
                    let usedKey;
                    
                    try {
                        // é¦–å…ˆå°è¯•å½“å‰å¯†é’¥ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                        if (currentKey) {
                            decryptedData = await decryptData(arrayBuffer, currentKey);
                            usedKey = currentKey;
                            showMessage(`ä½¿ç”¨å½“å‰å¯†é’¥è§£å¯†æˆåŠŸ: ${file.name}`, 'success');
                        } else {
                            // å½“å‰å¯†é’¥ä¸å­˜åœ¨ï¼Œå°è¯•è‡ªåŠ¨åŒ¹é…
                            const result = await autoMatchKeyAndDecrypt(file, arrayBuffer);
                            decryptedData = result.decryptedData;
                            usedKey = result.key;
                            showMessage(`è‡ªåŠ¨åŒ¹é…å¯†é’¥æˆåŠŸï¼Œä½¿ç”¨å¯†é’¥: ${usedKey.substring(0, 8)}... ${file.name}`, 'success');
                        }
                    } catch (error) {
                        // å½“å‰å¯†é’¥è§£å¯†å¤±è´¥ï¼Œå°è¯•è‡ªåŠ¨åŒ¹é…
                        try {
                            const result = await autoMatchKeyAndDecrypt(file, arrayBuffer);
                            decryptedData = result.decryptedData;
                            usedKey = result.key;
                            showMessage(`å½“å‰å¯†é’¥è§£å¯†å¤±è´¥ï¼Œè‡ªåŠ¨åŒ¹é…å¯†é’¥æˆåŠŸï¼Œä½¿ç”¨å¯†é’¥: ${usedKey.substring(0, 8)}... ${file.name}`, 'success');
                        } catch (autoMatchError) {
                            // è‡ªåŠ¨åŒ¹é…ä¹Ÿå¤±è´¥
                            throw autoMatchError;
                        }
                    }
                    
                    // ç¡®å®šåŸå§‹æ–‡ä»¶æ ¼å¼
                    const fileExtension = file.name.split('.').pop().toLowerCase();
                    let originalFormat = 'mp3';
                    
                    if (fileExtension === 'sflac') {
                        originalFormat = 'flac';
                    } else if (fileExtension === 'smp3') {
                        originalFormat = 'mp3';
                    } else if (fileExtension === 'lgg' || fileExtension === 'lav') {
                        originalFormat = 'wav'; // é»˜è®¤æ ¼å¼
                    }
                    
                    // åˆ›å»ºè§£å¯†æ–‡ä»¶
                    // è§£æåŸå§‹æ–‡ä»¶åè·å–æ­Œæ›²ä¿¡æ¯
                    const originalFileName = file.name.replace(/\.[^/.]+$/, '');
                    let title = originalFileName;
                    let artist = '';
                    
                    // å°è¯•ä»æ–‡ä»¶åä¸­æå–è‰ºæœ¯å®¶å’Œæ ‡é¢˜
                    const pattern = /^(.*?)\s*[-_]\s*(.*?)$/;
                    const match = originalFileName.match(pattern);
                    if (match && match[1] && match[2]) {
                        artist = match[1].trim() + ' - ';
                        title = match[2].trim();
                    }
                    
                    // ç”Ÿæˆå‹å¥½çš„è§£å¯†æ–‡ä»¶å
                    const decryptedFileName = artist + title + '.' + originalFormat;
                    const blob = new Blob([decryptedData], { type: `audio/${originalFormat}` });
                    
                    // æ·»åŠ åˆ°æ–‡ä»¶åˆ—è¡¨
                    addFileToList(decryptedFileName, blob);
                    
                    successCount++;
                } catch (error) {
                    console.error(`è§£å¯† ${file.name} å¤±è´¥:`, error);
                    showMessage(`è§£å¯†å¤±è´¥ ${i + 1}/${files.length}: ${file.name} - ${error.message}`, 'error');
                    failCount++;
                }
            }
            
            updateProgress(100);
            showMessage(`ä¸€é”®è§£å¯†å®Œæˆï¼æˆåŠŸ: ${successCount}ï¼Œå¤±è´¥: ${failCount}`, 'success');
        }
        
        // ç”Ÿæˆç¬¬äºŒä¸ªå¯†é’¥ï¼ˆåŸºäºåŸå§‹å¯†é’¥ï¼‰
        function generateSecondKey(key) {
            try {
                // ä½¿ç”¨SHA-256å“ˆå¸ŒåŸå§‹å¯†é’¥ï¼Œç”Ÿæˆç¬¬äºŒä¸ªå¯†é’¥
                return crypto.subtle.digest('SHA-256', new TextEncoder().encode(key))
                    .then(hashBuffer => {
                        const hashArray = Array.from(new Uint8Array(hashBuffer));
                        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                    })
                    .catch(error => {
                        console.error('ç”Ÿæˆç¬¬äºŒä¸ªå¯†é’¥å¤±è´¥:', error);
                        throw new Error('ç”Ÿæˆç¬¬äºŒä¸ªå¯†é’¥å¤±è´¥ï¼š' + error.message);
                    });
            } catch (error) {
                console.error('ç”Ÿæˆç¬¬äºŒä¸ªå¯†é’¥å¤±è´¥:', error);
                throw new Error('ç”Ÿæˆç¬¬äºŒä¸ªå¯†é’¥å¤±è´¥ï¼š' + error.message);
            }
        }
        
        // æ–‡ä»¶ç±»å‹æ£€æµ‹å‡½æ•°
        function detectFileType(fileName, fileData) {
            const extension = fileName.split('.').pop().toLowerCase();
            
            // åŸºäºæ–‡ä»¶æ‰©å±•åçš„æ£€æµ‹
            switch (extension) {
                // QQéŸ³ä¹
                case 'qmc3':
                case 'qmc0':
                case 'qmcflac':
                case 'qmcogg':
                case 'qmcwav':
                case 'qmcwm':
                    return { type: 'qqmusic', subtype: 'qmcv1' };
                case 'mflac':
                case 'mgg':
                case 'mflac0':
                case 'mgg1':
                case 'mggl':
                case 'mgalaxy':
                case 'mflach':
                    return { type: 'qqmusic', subtype: 'qmcv2' };
                // ç½‘æ˜“äº‘éŸ³ä¹
                case 'ncm':
                    return { type: 'netease' };
                // é…·ç‹—éŸ³ä¹
                case 'kgm':
                case 'vpr':
                case 'kgg':
                    return { type: 'kugou' };
                // é…·æˆ‘éŸ³ä¹
                case 'kwm':
                    return { type: 'kuwo' };
                // è™¾ç±³éŸ³ä¹
                case 'xm':
                    return { type: 'xiami' };
                // å–œé©¬æ‹‰é›…
                case 'x2m':
                case 'x3m':
                    return { type: 'ximalaya' };
                // å’ªå’•éŸ³ä¹
                case 'mg3d':
                    return { type: 'migu' };
                // èœ»èœ“FM
                case 'qta':
                    return { type: 'qingting' };
                // åŸæœ‰åŠ å¯†æ ¼å¼
                case 'smp3':
                case 'sflac':
                case 'lgg':
                case 'lav':
                    return { type: 'aes' };
                // æœªè¯†åˆ«æ ¼å¼
                default:
                    return { type: 'unknown' };
            }
        }
        
        // è·å–æ ¼å¼åŒ–çš„æ ¼å¼åç§°
        function getFormatName(fileType) {
            switch (fileType.type) {
                case 'qqmusic':
                    return fileType.subtype === 'qmcv1' ? 'QQéŸ³ä¹QMCv1' : 'QQéŸ³ä¹QMCv2';
                case 'netease':
                    return 'ç½‘æ˜“äº‘éŸ³ä¹';
                case 'kugou':
                    return 'é…·ç‹—éŸ³ä¹';
                case 'kuwo':
                    return 'é…·æˆ‘éŸ³ä¹';
                case 'xiami':
                    return 'è™¾ç±³éŸ³ä¹';
                case 'ximalaya':
                    return 'å–œé©¬æ‹‰é›…';
                case 'migu':
                    return 'å’ªå’•éŸ³ä¹';
                case 'qingting':
                    return 'èœ»èœ“FM';
                case 'aes':
                    return 'AESåŠ å¯†';
                default:
                    return 'æœªçŸ¥æ ¼å¼';
            }
        }
        
        // åŠ å¯†æ•°æ®ï¼ˆç®€åŒ–åŠ å¯†ï¼Œå…¼å®¹æ—§ç‰ˆæœ¬ï¼‰
        async function encryptData(data, key) {
            try {
                // ä½¿ç”¨AES-GCMè¿›è¡Œå•é‡åŠ å¯†ï¼ˆå…¼å®¹æ—§ç‰ˆæœ¬ï¼‰
                const encoder = new TextEncoder();
                const keyData = encoder.encode(key);
                
                // éªŒè¯å¯†é’¥é•¿åº¦
                if (key.length !== 32) {
                    throw new Error('å¯†é’¥é•¿åº¦é”™è¯¯ï¼Œå¿…é¡»ä¸º32ä½åå…­è¿›åˆ¶å­—ç¬¦');
                }
                
                // ç”ŸæˆåŠ å¯†å¯†é’¥
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    keyData,
                    { name: 'AES-GCM' },
                    false,
                    ['encrypt']
                );
                
                // ç”ŸæˆéšæœºIV
                const iv = crypto.getRandomValues(new Uint8Array(12));
                
                // åŠ å¯†æ•°æ®
                const encryptedData = await crypto.subtle.encrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv
                    },
                    cryptoKey,
                    data
                );
                
                // åˆå¹¶IVå’ŒåŠ å¯†æ•°æ®ï¼ˆæ—§ç‰ˆæœ¬æ ¼å¼ï¼‰
                const result = new Uint8Array(iv.length + encryptedData.byteLength);
                result.set(iv);
                result.set(new Uint8Array(encryptedData), iv.length);
                
                return result;
            } catch (error) {
                console.error('åŠ å¯†æ•°æ®å¤±è´¥:', error);
                if (error.message.includes('key length')) {
                    throw new Error('åŠ å¯†å¤±è´¥ï¼šå¯†é’¥é•¿åº¦é”™è¯¯');
                } else if (error.message.includes('Invalid key data')) {
                    throw new Error('åŠ å¯†å¤±è´¥ï¼šå¯†é’¥æ ¼å¼é”™è¯¯');
                } else {
                    throw new Error('åŠ å¯†å¤±è´¥ï¼š' + error.message);
                }
            }
        }
        
        // è§£å¯†æ•°æ®ï¼ˆå…¼å®¹å•é‡åŠ å¯†å’ŒåŒé‡åŠ å¯†ï¼‰
        async function decryptData(data, key) {
            const encoder = new TextEncoder();
            
            try {
                // éªŒè¯å¯†é’¥é•¿åº¦
                if (key.length !== 32) {
                    throw new Error('å¯†é’¥é•¿åº¦é”™è¯¯ï¼Œå¿…é¡»ä¸º32ä½åå…­è¿›åˆ¶å­—ç¬¦');
                }
                
                // éªŒè¯æ•°æ®é•¿åº¦
                if (data.byteLength < 13) {
                    throw new Error('è§£å¯†å¤±è´¥ï¼šæ•°æ®é•¿åº¦ä¸è¶³ï¼Œä¸æ˜¯æœ‰æ•ˆçš„åŠ å¯†æ–‡ä»¶');
                }
                
                // å°è¯•åŒé‡è§£å¯†
                try {
                    // ç”Ÿæˆç¬¬äºŒä¸ªå¯†é’¥
                    const secondKey = await generateSecondKey(key);
                    const secondKeyData = encoder.encode(secondKey);
                    
                    // ç”Ÿæˆç¬¬äºŒä¸ªè§£å¯†å¯†é’¥
                    const cryptoKey2 = await crypto.subtle.importKey(
                        'raw',
                        secondKeyData,
                        { name: 'AES-GCM' },
                        false,
                        ['decrypt']
                    );
                    
                    // åˆ†ç¦»ç¬¬äºŒæ¬¡åŠ å¯†çš„IVå’ŒåŠ å¯†æ•°æ®
                    const iv2 = data.slice(0, 12);
                    const encrypted2 = data.slice(12);
                    
                    // ç¬¬ä¸€æ¬¡è§£å¯†ï¼ˆå¯¹åº”ç¬¬äºŒæ¬¡åŠ å¯†ï¼‰
                    const decrypted2 = await crypto.subtle.decrypt(
                        {
                            name: 'AES-GCM',
                            iv: iv2
                        },
                        cryptoKey2,
                        encrypted2
                    );
                    
                    // æ£€æŸ¥ç¬¬ä¸€æ¬¡è§£å¯†ç»“æœ
                    if (new Uint8Array(decrypted2).length < 13) {
                        throw new Error('ç¬¬ä¸€æ¬¡è§£å¯†å¤±è´¥ï¼Œç»“æœé•¿åº¦ä¸è¶³');
                    }
                    
                    // ç”Ÿæˆç¬¬ä¸€ä¸ªè§£å¯†å¯†é’¥
                    const keyData = encoder.encode(key);
                    const cryptoKey1 = await crypto.subtle.importKey(
                        'raw',
                        keyData,
                        { name: 'AES-GCM' },
                        false,
                        ['decrypt']
                    );
                    
                    // åˆ†ç¦»ç¬¬ä¸€æ¬¡åŠ å¯†çš„IVå’ŒåŠ å¯†æ•°æ®
                    const decrypted2Array = new Uint8Array(decrypted2);
                    const iv1 = decrypted2Array.slice(0, 12);
                    const encrypted1 = decrypted2Array.slice(12);
                    
                    // ç¬¬äºŒæ¬¡è§£å¯†ï¼ˆå¯¹åº”ç¬¬ä¸€æ¬¡åŠ å¯†ï¼‰
                    const decrypted1 = await crypto.subtle.decrypt(
                        {
                            name: 'AES-GCM',
                            iv: iv1
                        },
                        cryptoKey1,
                        encrypted1
                    );
                    
                    return new Uint8Array(decrypted1);
                } catch (doubleDecryptError) {
                    // åŒé‡è§£å¯†å¤±è´¥ï¼Œå°è¯•å•é‡è§£å¯†ï¼ˆå…¼å®¹æ—§ç‰ˆæœ¬ï¼‰
                    try {
                        // ç”Ÿæˆè§£å¯†å¯†é’¥
                        const keyData = encoder.encode(key);
                        const cryptoKey = await crypto.subtle.importKey(
                            'raw',
                            keyData,
                            { name: 'AES-GCM' },
                            false,
                            ['decrypt']
                        );
                        
                        // åˆ†ç¦»IVå’ŒåŠ å¯†æ•°æ®ï¼ˆæ—§ç‰ˆæœ¬æ ¼å¼ï¼‰
                        const iv = data.slice(0, 12);
                        const encryptedData = data.slice(12);
                        
                        // å•é‡è§£å¯†
                        const decryptedData = await crypto.subtle.decrypt(
                            {
                                name: 'AES-GCM',
                                iv: iv
                            },
                            cryptoKey,
                            encryptedData
                        );
                        
                        return new Uint8Array(decryptedData);
                    } catch (singleDecryptError) {
                        // å•é‡è§£å¯†ä¹Ÿå¤±è´¥ï¼ŒæŠ›å‡ºæ›´è¯¦ç»†çš„é”™è¯¯
                        if (singleDecryptError.message.includes('authentication failure')) {
                            throw new Error('è§£å¯†å¤±è´¥ï¼šå¯†é’¥é”™è¯¯æˆ–æ–‡ä»¶å·²æŸå');
                        } else if (singleDecryptError.message.includes('Invalid key data')) {
                            throw new Error('è§£å¯†å¤±è´¥ï¼šå¯†é’¥æ ¼å¼é”™è¯¯');
                        } else {
                            throw new Error('è§£å¯†å¤±è´¥ï¼šä¸æ”¯æŒçš„åŠ å¯†æ ¼å¼æˆ–æ–‡ä»¶å·²æŸå');
                        }
                    }
                }
            } catch (error) {
                console.error('è§£å¯†æ•°æ®å¤±è´¥:', error);
                throw error;
            }
        }
        
        // æ·»åŠ æ–‡ä»¶åˆ°åˆ—è¡¨
        function addFileToList(fileName, blob) {
            const fileList = document.getElementById('file-list');
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            
            const fileUrl = URL.createObjectURL(blob);
            
            // è§£ææ­Œæ›²å…ƒæ•°æ® - ç›´æ¥ä½¿ç”¨fileNameè§£æï¼Œä¸ä½¿ç”¨URL
            // åˆ›å»ºä¸€ä¸ªä¸´æ—¶å¯¹è±¡æ¥è§£æå…ƒæ•°æ®
            let cleanName = fileName.replace(/\.[^/.]+$/, '');
            let title = cleanName;
            let artist = 'æœªçŸ¥è‰ºæœ¯å®¶';
            
            // å°è¯•ä»æ–‡ä»¶åä¸­æå–è‰ºæœ¯å®¶å’Œæ ‡é¢˜ï¼Œæ”¯æŒå¤šç§æ ¼å¼
            const patterns = [
                /^(.*?)\s*[-_]\s*(.*?)$/,        // æ ¼å¼ï¼šè‰ºæœ¯å®¶ - æ ‡é¢˜
                /^(.*?)\s*[ï¼]\s*(.*?)$/,     // æ ¼å¼ï¼šè‰ºæœ¯å®¶ ï¼ æ ‡é¢˜ï¼ˆå…¨è§’ç ´æŠ˜å·ï¼‰
                /^(.*?)\s*[ï¼š:]\s*(.*?)$/      // æ ¼å¼ï¼šè‰ºæœ¯å®¶:æ ‡é¢˜ï¼ˆå…¨è§’å†’å·ï¼‰
            ];
            
            for (const pattern of patterns) {
                const match = cleanName.match(pattern);
                if (match && match[1] && match[2]) {
                    artist = match[1].trim();
                    title = match[2].trim();
                    break;
                }
            }
            
            // å»é™¤å¸¸è§çš„æ–‡ä»¶åå‰ç¼€å’Œåç¼€
            title = title.replace(/^\d+\s*[-.]?\s*/, ''); // å»é™¤æ•°å­—å‰ç¼€
            artist = artist.replace(/^\d+\s*[-.]?\s*/, ''); // å»é™¤æ•°å­—å‰ç¼€
            
            // åˆ›å»ºå‹å¥½çš„æ–‡ä»¶åæ˜¾ç¤º
            const displayName = decodeURIComponent(fileName);
            
            // æ„å»ºæ–‡ä»¶é¡¹å†…å®¹
            fileItem.innerHTML = `
                <div style="flex: 1;">
                    <div style="font-weight: bold; margin-bottom: 4px;">${title}</div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 2px;">${artist}</div>
                    <div style="font-size: 11px; color: #999;">${displayName}</div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 4px;">
                    <button onclick="downloadFile('${fileUrl}', '${fileName}')" style="padding: 5px 10px; font-size: 14px;">ä¸‹è½½</button>
                    <button onclick="playFile('${fileUrl}')" style="padding: 5px 10px; font-size: 14px;">æ’­æ”¾</button>
                </div>
            `;
            
            fileList.appendChild(fileItem);
            
            // ä¿å­˜åˆ°å¤„ç†åçš„æ–‡ä»¶åˆ—è¡¨
            processedFiles.push({ url: fileUrl, name: fileName, blob: blob });
        }
        
        // ä¸‹è½½æ–‡ä»¶
        function downloadFile(url, fileName) {
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        
        // æ’­æ”¾æ–‡ä»¶
        function playFile(url) {
            const audioPlayer = document.getElementById('audio-player');
            audioPlayer.src = url;
            audioPlayer.play();
        }
        
        // æ¸…é™¤æ–‡ä»¶åˆ—è¡¨
        function clearFileList() {
            const fileList = document.getElementById('file-list');
            
            // é‡Šæ”¾æ‰€æœ‰URLå¯¹è±¡
            processedFiles.forEach(file => {
                URL.revokeObjectURL(file.url);
            });
            
            // æ¸…ç©ºæ–‡ä»¶åˆ—è¡¨å’Œæ•°ç»„
            fileList.innerHTML = '';
            processedFiles = [];
            
            showMessage('æ–‡ä»¶åˆ—è¡¨å·²æ¸…ç©º', 'success');
        }
        
        // æ‰¹é‡ä¸‹è½½æ–‡ä»¶
        function batchDownloadFiles() {
            if (processedFiles.length === 0) {
                showMessage('æ²¡æœ‰å¯ä¸‹è½½çš„æ–‡ä»¶', 'error');
                return;
            }
            
            // éå†æ‰€æœ‰æ–‡ä»¶å¹¶ä¸‹è½½
            processedFiles.forEach(file => {
                downloadFile(file.url, file.name);
            });
            
            showMessage(`å·²å¼€å§‹æ‰¹é‡ä¸‹è½½ ${processedFiles.length} ä¸ªæ–‡ä»¶`, 'success');
        }
        
        // åŠ è½½åŠ å¯†éŸ³é¢‘ç”¨äºæ’­æ”¾ï¼ˆv3.0ä¼˜åŒ–ï¼‰
        function loadEncryptedAudio() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.smp3,.sflac,.lgg,.lav,.mp3,.flac,.wav'; // æ”¯æŒæ‰€æœ‰éŸ³é¢‘æ ¼å¼
            input.multiple = true; // æ”¯æŒå¤šé€‰
            input.onchange = async (e) => {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;
                
                // å¤„ç†ç¬¬ä¸€ä¸ªæ–‡ä»¶
                const file = files[0];
                try {
                    // åŒæ­¥åˆ°ç¬¬1éƒ¨åˆ†
                    currentFile = file;
                    
                    // æ›´æ–°ç¬¬1éƒ¨åˆ†çš„æ–‡ä»¶ä¿¡æ¯æ˜¾ç¤º
                    const fileInfo = `æ–‡ä»¶å: ${file.name}<br>æ–‡ä»¶å¤§å°: ${(file.size / (1024 * 1024)).toFixed(2)} MB<br>ç±»å‹: ${file.type}`;
                    const fileInfoElement = document.getElementById('file-info');
                    if (fileInfoElement) {
                        fileInfoElement.innerHTML = fileInfo;
                    }
                    showMessage(`æ–‡ä»¶å·²é€‰æ‹©: ${file.name}`, 'success');
                    
                    // æ›´æ–°æ’­æ”¾å™¨ä¿¡æ¯
                    updatePlayerInfo(file.name, 'åŠ è½½ä¸­...', '');
                    
                    // æ£€æŸ¥æ˜¯å¦ä¸ºåŠ å¯†æ–‡ä»¶
                    const fileExtension = file.name.split('.').pop().toLowerCase();
                    const isEncrypted = ['.smp3', '.sflac', '.lgg', '.lav'].includes('.' + fileExtension);
                    
                    let url;
                    if (isEncrypted) {
                        // æ˜¾ç¤ºè§£å¯†çŠ¶æ€
                        showPlayStatus('decrypting');
                        
                        // æ£€æŸ¥æ˜¯å¦æœ‰å¯†é’¥
                        if (!currentKey) {
                            showMessage('è¯·å…ˆç”Ÿæˆå¯†é’¥', 'error');
                            showPlayStatus('ready');
                            updatePlayerInfo(file.name, 'æœªçŸ¥è‰ºæœ¯å®¶', 'æœªçŸ¥ä¸“è¾‘');
                            return;
                        }
                        
                        const arrayBuffer = await file.arrayBuffer();
                        const decryptedData = await decryptData(arrayBuffer, currentKey);
                        
                        // ç¡®å®šåŸå§‹éŸ³é¢‘æ ¼å¼
                        let audioFormat = 'mp3';
                        if (fileExtension === 'sflac') {
                            audioFormat = 'flac';
                        } else if (fileExtension === 'smp3') {
                            audioFormat = 'mp3';
                        } else {
                            audioFormat = 'wav';
                        }
                        
                        const blob = new Blob([decryptedData], { type: `audio/${audioFormat}` });
                        url = URL.createObjectURL(blob);
                    } else {
                        // éåŠ å¯†æ–‡ä»¶ï¼Œç›´æ¥åˆ›å»ºURL
                        url = URL.createObjectURL(file);
                    }
                    
                    // æ›´æ–°æ’­æ”¾å™¨ä¿¡æ¯
                    updatePlayerInfo(file.name, 'æœªçŸ¥è‰ºæœ¯å®¶', 'æœªçŸ¥ä¸“è¾‘');
                    
                    // åŠ è½½å¹¶æ’­æ”¾éŸ³é¢‘
                    const audioPlayer = document.getElementById('audio-player');
                    audioPlayer.src = url;
                    await audioPlayer.play();
                    
                    showMessage(`æˆåŠŸæ’­æ”¾: ${file.name}`, 'success');
                } catch (error) {
                    showMessage(`å¤„ç† ${file.name} å¤±è´¥: ${error.message}`, 'error');
                    console.error('åŠ è½½éŸ³é¢‘å¤±è´¥:', error);
                    updatePlayerInfo(file.name, 'æœªçŸ¥è‰ºæœ¯å®¶', 'æœªçŸ¥ä¸“è¾‘');
                    showPlayStatus('ready');
                }
            };
            input.click();
        }
        
        // æ›´æ–°æ’­æ”¾å™¨ä¿¡æ¯
        function updatePlayerInfo(title, artist, album) {
            document.getElementById('advanced-title').textContent = title;
            document.getElementById('advanced-artist').textContent = artist;
            document.getElementById('advanced-album').textContent = album;
        }
        
        // ä¸€é”®è§£å¯†æ­£åœ¨æ’­æ”¾çš„æ–‡ä»¶
        async function decryptCurrentlyPlaying() {
            // æ£€æŸ¥currentFileæ˜¯å¦å­˜åœ¨ï¼ˆä¼˜å…ˆä½¿ç”¨currentFileï¼Œå› ä¸ºå®ƒåŒ…å«åŸå§‹æ–‡ä»¶ä¿¡æ¯ï¼‰
            if (!currentFile) {
                showMessage('æœªæ‰¾åˆ°å½“å‰æ’­æ”¾æ–‡ä»¶çš„åŸå§‹ä¿¡æ¯', 'error');
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰å¯†é’¥
            const keys = loadKeys();
            if (!currentKey && keys.length === 0) {
                showMessage('è¯·å…ˆç”Ÿæˆæˆ–æ·»åŠ å¯†é’¥', 'error');
                return;
            }
            
            try {
                // æ˜¾ç¤ºè§£å¯†çŠ¶æ€
                showPlayStatus('decrypting');
                showMessage(`å¼€å§‹è§£å¯†å½“å‰æ’­æ”¾æ–‡ä»¶: ${currentFile.name}`);
                updateProgress(0);
                
                // è¯»å–æ–‡ä»¶å†…å®¹
                const arrayBuffer = await currentFile.arrayBuffer();
                updateProgress(20);
                
                // æ£€æµ‹æ–‡ä»¶ç±»å‹
                const fileType = detectFileType(currentFile.name, arrayBuffer);
                
                // åªå¤„ç†AESåŠ å¯†æ ¼å¼
                if (fileType.type !== 'aes') {
                    showMessage(`å½“å‰æ’­æ”¾æ–‡ä»¶ ${currentFile.name} ä¸æ˜¯AESåŠ å¯†æ ¼å¼`, 'info');
                    showPlayStatus('ready');
                    updateProgress(100);
                    return;
                }
                
                // ä½¿ç”¨è‡ªåŠ¨åŒ¹é…å¯†é’¥è§£å¯†
                let decryptedData;
                let usedKey;
                
                try {
                    // ä½¿ç”¨å½“å‰å¯†é’¥è§£å¯†
                    if (currentKey) {
                        decryptedData = await decryptData(arrayBuffer, currentKey);
                        usedKey = currentKey;
                        showMessage(`ä½¿ç”¨å½“å‰å¯†é’¥è§£å¯†æˆåŠŸ: ${currentFile.name}`, 'success');
                    } else {
                        // å½“å‰å¯†é’¥ä¸å­˜åœ¨ï¼Œç›´æ¥ä½¿ç”¨è‡ªåŠ¨åŒ¹é…
                        const result = await autoMatchKeyAndDecrypt(currentFile, arrayBuffer);
                        decryptedData = result.decryptedData;
                        usedKey = result.key;
                        showMessage(`è‡ªåŠ¨åŒ¹é…å¯†é’¥æˆåŠŸï¼Œä½¿ç”¨å¯†é’¥: ${usedKey.substring(0, 8)}... ${currentFile.name}`, 'success');
                    }
                } catch (error) {
                    // å½“å‰å¯†é’¥è§£å¯†å¤±è´¥ï¼Œå°è¯•è‡ªåŠ¨åŒ¹é…
                    try {
                        const result = await autoMatchKeyAndDecrypt(currentFile, arrayBuffer);
                        decryptedData = result.decryptedData;
                        usedKey = result.key;
                        showMessage(`å½“å‰å¯†é’¥è§£å¯†å¤±è´¥ï¼Œè‡ªåŠ¨åŒ¹é…å¯†é’¥æˆåŠŸï¼Œä½¿ç”¨å¯†é’¥: ${usedKey.substring(0, 8)}... ${currentFile.name}`, 'success');
                    } catch (autoMatchError) {
                        // è‡ªåŠ¨åŒ¹é…ä¹Ÿå¤±è´¥
                        throw autoMatchError;
                    }
                }
                updateProgress(80);
                
                // ç¡®å®šåŸå§‹æ–‡ä»¶æ ¼å¼
                const fileExtension = currentFile.name.split('.').pop().toLowerCase();
                let originalFormat = 'mp3';
                
                if (fileExtension === 'sflac') {
                    originalFormat = 'flac';
                } else if (fileExtension === 'smp3') {
                    originalFormat = 'mp3';
                } else if (fileExtension === 'lgg' || fileExtension === 'lav') {
                    originalFormat = 'wav'; // é»˜è®¤æ ¼å¼
                }
                
                // åˆ›å»ºè§£å¯†æ–‡ä»¶
                // è§£æåŸå§‹æ–‡ä»¶åè·å–æ­Œæ›²ä¿¡æ¯
                const originalFileName = currentFile.name.replace(/\.[^/.]+$/, '');
                let title = originalFileName;
                let artist = '';
                
                // å°è¯•ä»æ–‡ä»¶åä¸­æå–è‰ºæœ¯å®¶å’Œæ ‡é¢˜
                const patterns = [
                    /^(.*?)\s*[-_]\s*(.*?)$/,        // æ ¼å¼ï¼šè‰ºæœ¯å®¶ - æ ‡é¢˜
                    /^(.*?)\s*[ï¼]\s*(.*?)$/,     // æ ¼å¼ï¼šè‰ºæœ¯å®¶ ï¼ æ ‡é¢˜ï¼ˆå…¨è§’ç ´æŠ˜å·ï¼‰
                    /^(.*?)\s*[ï¼š:]\s*(.*?)$/      // æ ¼å¼ï¼šè‰ºæœ¯å®¶:æ ‡é¢˜ï¼ˆå…¨è§’å†’å·ï¼‰
                ];
                
                let match;
                for (const pattern of patterns) {
                    match = originalFileName.match(pattern);
                    if (match && match[1] && match[2]) {
                        artist = match[1].trim() + ' - ';
                        title = match[2].trim();
                        break;
                    }
                }
                
                // ç”Ÿæˆå‹å¥½çš„è§£å¯†æ–‡ä»¶å
                const decryptedFileName = artist + title + '.' + originalFormat;
                const blob = new Blob([decryptedData], { type: `audio/${originalFormat}` });
                
                // æ·»åŠ åˆ°æ–‡ä»¶åˆ—è¡¨
                addFileToList(decryptedFileName, blob);
                
                // æ›´æ–°æ’­æ”¾å™¨ï¼Œå°è¯•æ’­æ”¾è§£å¯†åçš„æ–‡ä»¶
                const audioPlayer = document.getElementById('audio-player');
                const decryptedUrl = URL.createObjectURL(blob);
                audioPlayer.src = decryptedUrl;
                audioPlayer.play();
                
                updateProgress(100);
                showMessage(`æˆåŠŸè§£å¯†å½“å‰æ’­æ”¾æ–‡ä»¶: ${currentFile.name}ï¼Œæ­£åœ¨æ’­æ”¾è§£å¯†åçš„ç‰ˆæœ¬`, 'success');
                showPlayStatus('playing');
            } catch (error) {
                console.error('è§£å¯†å½“å‰æ’­æ”¾æ–‡ä»¶å¤±è´¥:', error);
                showMessage(`è§£å¯†å½“å‰æ’­æ”¾æ–‡ä»¶å¤±è´¥: ${error.message}`, 'error');
                showPlayStatus('ready');
            }
        }
        
        // è‡ªåŠ¨è§£å¯†åŠŸèƒ½å·²é»˜è®¤å¼€å¯ï¼Œä¸”ä¸å¯å…³é—­
        // è¿™é‡Œä»…å®ç°UIæ›´æ–°ï¼Œå®é™…åŠŸèƒ½å·²é›†æˆåˆ°æ’­æ”¾å™¨é€»è¾‘ä¸­
        
        // åˆ‡æ¢è®¾ç½®é¢æ¿æ˜¾ç¤º
        function toggleSettings() {
            const settingsPanel = document.getElementById('settings-panel');
            settingsPanel.classList.toggle('show');
            // å½“è®¾ç½®é¢æ¿æ‰“å¼€æ—¶ï¼Œæ›´æ–°å¯†é’¥åˆ—è¡¨
            if (settingsPanel.classList.contains('show')) {
                displayKeys();
            }
        }
        
        // åˆ‡æ¢æ’­æ”¾çŠ¶æ€
        function togglePlay() {
            const audioPlayer = document.getElementById('audio-player');
            const playBtn = document.getElementById('advanced-play-btn');
            
            if (audioPlayer.paused) {
                audioPlayer.play();
                playBtn.innerHTML = 'â¸ï¸';
            } else {
                audioPlayer.pause();
                playBtn.innerHTML = 'â–¶ï¸';
            }
        }
        
        // è¿›åº¦æ¡ç‚¹å‡»äº‹ä»¶
        function seekAudio(e) {
            const audioPlayer = document.getElementById('audio-player');
            const progressBar = e.target;
            const rect = progressBar.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percentage = x / rect.width;
            audioPlayer.currentTime = percentage * audioPlayer.duration;
        }
        
        // è®¾ç½®éŸ³é‡
        function setVolume(e) {
            const volumeSlider = e.target;
            const rect = volumeSlider.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percentage = x / rect.width;
            updateVolume(percentage);
        }
        
        // æ›´æ–°éŸ³é‡å’Œæ˜¾ç¤º
        function updateVolume(percentage) {
            const audioPlayer = document.getElementById('audio-player');
            const volumeLevel = Math.max(0, Math.min(1, percentage));
            audioPlayer.volume = volumeLevel;
            
            // æ›´æ–°éŸ³é‡æ»‘å—å¡«å……
            const volumeFill = document.getElementById('volume-fill');
            const volumeHandle = document.getElementById('volume-handle');
            const volumeLevelDisplay = document.getElementById('volume-level');
            
            const percentageValue = Math.round(volumeLevel * 100);
            volumeFill.style.width = `${percentageValue}%`;
            volumeHandle.style.left = `${percentageValue}%`;
            volumeLevelDisplay.textContent = `${percentageValue}%`;
        }
        
        // éŸ³é‡æ‹–åŠ¨å¼€å§‹
        function startVolumeDrag(e) {
            // é˜»æ­¢é»˜è®¤è¡Œä¸º
            e.preventDefault();
            
            // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
            document.addEventListener('mousemove', volumeDrag);
            document.addEventListener('mouseup', stopVolumeDrag);
            
            // åˆå§‹æ‹–åŠ¨
            volumeDrag(e);
        }
        
        // éŸ³é‡æ‹–åŠ¨ä¸­
        function volumeDrag(e) {
            const volumeSlider = document.querySelector('.volume-slider');
            const rect = volumeSlider.getBoundingClientRect();
            const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
            const percentage = x / rect.width;
            updateVolume(percentage);
        }
        
        // éŸ³é‡æ‹–åŠ¨ç»“æŸ
        function stopVolumeDrag() {
            // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
            document.removeEventListener('mousemove', volumeDrag);
            document.removeEventListener('mouseup', stopVolumeDrag);
        }
        
        // ä¸€é”®åŠ å¯†
        async function quickEncrypt() {
            // æ˜¾ç¤ºæç¤ºä¿¡æ¯
            showMessage('ä¸€é”®åŠ å¯†åŠŸèƒ½å¼€å‘ä¸­ï¼Œæ•¬è¯·æœŸå¾…', 'info');
        }
        
        // ä¸€é”®è§£å¯†
        async function quickDecrypt() {
            // è°ƒç”¨ä¸€é”®è§£å¯†åŠŸèƒ½
            oneClickDecrypt();
        }
        
        // ä¸€é”®æ‰«æå¯¼å…¥
        async function oneClickScan() {
            // æ˜¾ç¤ºæç¤ºä¿¡æ¯
            showMessage('ä¸€é”®æ‰«æå¯¼å…¥åŠŸèƒ½å¼€å‘ä¸­ï¼Œæ•¬è¯·æœŸå¾…', 'info');
        }
        
        // ç”Ÿæˆè®¾å¤‡ç ï¼ˆé«˜çº§æ’­æ”¾å™¨ï¼‰
        function generateDeviceCodeAdvanced() {
            const deviceCode = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
            document.getElementById('advanced-device-code').value = deviceCode;
        }
        
        // ç”Ÿæˆå¯†é’¥ï¼ˆé«˜çº§æ’­æ”¾å™¨ï¼‰
        async function generateKeyAdvanced() {
            const deviceCode = document.getElementById('advanced-device-code').value;
            if (!deviceCode) {
                // ç”Ÿæˆéšæœºè®¾å¤‡ç 
                generateDeviceCodeAdvanced();
                showMessage('å·²è‡ªåŠ¨ç”Ÿæˆè®¾å¤‡ç ï¼Œæ­£åœ¨ç”Ÿæˆå¯†é’¥...', 'info');
            }
            
            // ä½¿ç”¨SHA-256ç”Ÿæˆå¯†é’¥
            const encoder = new TextEncoder();
            const data = encoder.encode(deviceCode);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const keyHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            
            // æˆªå–å‰32å­—èŠ‚ä½œä¸ºAESå¯†é’¥
            currentKey = keyHex.substring(0, 32);
            document.getElementById('advanced-key-display').textContent = `å¯†é’¥: ${currentKey}`;
            
            // ä¿å­˜å¯†é’¥åˆ°localStorage
            localStorage.setItem('audioEncryptorKey', currentKey);
        }
        
        // ä½¿ç”¨um-react APIè§£å¯†å¹³å°åŠ å¯†æ–‡ä»¶
        async function decryptWithUmReact(file, arrayBuffer) {
            try {
                const formData = new FormData();
                formData.append('file', new Blob([arrayBuffer]), file.name);
                
                const response = await fetch('https://demo.unlock-music.dev/api/unlock', {
                    method: 'POST',
                    body: formData,
                    mode: 'cors'
                });
                
                if (!response.ok) {
                    throw new Error(`è§£å¯†å¤±è´¥: ${response.status} ${response.statusText}`);
                }
                
                // è·å–è§£å¯†åçš„æ–‡ä»¶åå’Œç±»å‹
                const contentDisposition = response.headers.get('content-disposition');
                let decryptedFileName = file.name.replace(/\.[^/.]+$/, '.mp3');
                if (contentDisposition) {
                    const match = contentDisposition.match(/filename="?([^";]+)"?/);
                    if (match) {
                        decryptedFileName = match[1];
                    }
                }
                
                // è·å–è§£å¯†åçš„éŸ³é¢‘æ•°æ®
                const decryptedArrayBuffer = await response.arrayBuffer();
                const blob = new Blob([decryptedArrayBuffer], { type: 'audio/mpeg' });
                
                return {
                    name: decryptedFileName,
                    blob: blob,
                    originalName: file.name
                };
            } catch (error) {
                console.error('è§£å¯†é”™è¯¯:', error);
                throw error;
            }
        }
        
        // è§£å¯†å•ä¸ªæ–‡ä»¶ï¼ˆå¸¦å¹¶å‘æ§åˆ¶ï¼‰
        async function decryptSingleFile(file) {
            try {
                concurrentDecryptCount++;
                
                // è¯»å–æ–‡ä»¶å†…å®¹
                const arrayBuffer = await file.arrayBuffer();
                
                // è°ƒç”¨è§£å¯†API
                const decryptedFile = await decryptWithUmReact(file, arrayBuffer);
                
                // ä½¿ç”¨requestAnimationFrameä¼˜åŒ–UIæ›´æ–°
                requestAnimationFrame(() => {
                    platformDecryptedFiles.push(decryptedFile);
                    updatePlatformDecryptedList();
                    
                    // æ›´æ–°è¿›åº¦
                    decryptProgress.completed++;
                    updateDecryptProgress();
                });
            } catch (error) {
                requestAnimationFrame(() => {
                    showPlatformMessage(`æ–‡ä»¶ ${file.name} è§£å¯†å¤±è´¥: ${error.message}`, 'error');
                    decryptProgress.completed++;
                    updateDecryptProgress();
                });
            } finally {
                concurrentDecryptCount--;
                processDecryptQueue();
            }
        }
        
        // å¤„ç†è§£å¯†é˜Ÿåˆ—
        function processDecryptQueue() {
            if (decryptQueue.length > 0 && concurrentDecryptCount < MAX_CONCURRENT_DECRYPT) {
                const file = decryptQueue.shift();
                decryptSingleFile(file);
            } else if (concurrentDecryptCount === 0 && decryptQueue.length === 0 && decryptProgress.completed < decryptProgress.total) {
                // æ‰€æœ‰æ–‡ä»¶å¤„ç†å®Œæˆ
                decryptProgress.completed = decryptProgress.total;
                updateDecryptProgress();
                showPlatformMessage('æ‰€æœ‰æ–‡ä»¶è§£å¯†å®Œæˆ', 'success');
            }
        }
        
        // æ›´æ–°è§£å¯†è¿›åº¦
        function updateDecryptProgress() {
            const progressElement = document.getElementById('platform-decrypt-progress');
            const progressText = document.getElementById('platform-decrypt-progress-text');
            const progressFill = document.getElementById('platform-decrypt-progress-fill');
            
            if (decryptProgress.total === 0) {
                progressElement.style.display = 'none';
                return;
            }
            
            progressElement.style.display = 'block';
            const progressPercent = Math.round((decryptProgress.completed / decryptProgress.total) * 100);
            progressText.textContent = `${decryptProgress.completed}/${decryptProgress.total}`;
            progressFill.style.width = `${progressPercent}%`;
        }
        
        // æ˜¾ç¤ºå¹³å°è§£å¯†æ¶ˆæ¯
        function showPlatformMessage(message, type = 'info') {
            const messageElement = document.getElementById('platform-decrypt-message');
            messageElement.textContent = message;
            messageElement.className = type;
            
            // 3ç§’åè‡ªåŠ¨æ¸…é™¤æ¶ˆæ¯
            setTimeout(() => {
                if (messageElement.textContent === message) {
                    messageElement.textContent = '';
                    messageElement.className = '';
                }
            }, 3000);
        }
        
        // æ›´æ–°å¹³å°è§£å¯†åˆ—è¡¨
        function updatePlatformDecryptedList() {
            const listElement = document.getElementById('platform-decrypted-list');
            
            if (platformDecryptedFiles.length === 0) {
                listElement.innerHTML = '<p>æš‚æ— è§£å¯†ç»“æœ</p>';
                return;
            }
            
            listElement.innerHTML = platformDecryptedFiles.map((file, index) => {
                const fileUrl = URL.createObjectURL(file.blob);
                return `
                    <div class="file-item">
                        <div style="flex: 1;">
                            <div style="font-weight: bold; margin-bottom: 4px;">${file.name}</div>
                            <div style="font-size: 12px; color: #666; margin-bottom: 2px;">åŸå§‹æ–‡ä»¶: ${file.originalName}</div>
                            <div style="font-size: 11px; color: #999;">å¤§å°: ${(file.blob.size / (1024 * 1024)).toFixed(2)} MB</div>
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 4px;">
                            <button onclick="downloadFile('${fileUrl}', '${file.name}')" style="padding: 5px 10px; font-size: 14px;">ä¸‹è½½</button>
                            <button onclick="playFile('${fileUrl}')" style="padding: 5px 10px; font-size: 14px;">æ’­æ”¾</button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // å¼€å§‹è§£å¯†å¹³å°æ–‡ä»¶
        async function decryptPlatformFiles() {
            const fileInput = document.getElementById('platform-files');
            const folderInput = document.getElementById('platform-folder-upload');
            
            let files = [];
            
            // è·å–é€‰æ‹©çš„æ–‡ä»¶
            if (fileInput.files.length > 0) {
                files = Array.from(fileInput.files);
            } else if (folderInput.files.length > 0) {
                files = Array.from(folderInput.files);
            }
            
            if (files.length === 0) {
                showPlatformMessage('è¯·å…ˆé€‰æ‹©è¦è§£å¯†çš„æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹', 'error');
                return;
            }
            
            // é‡ç½®çŠ¶æ€
            platformDecryptedFiles = [];
            decryptQueue = [...files];
            decryptProgress = { total: files.length, completed: 0 };
            updatePlatformDecryptedList();
            updateDecryptProgress();
            showPlatformMessage(`å¼€å§‹è§£å¯† ${files.length} ä¸ªæ–‡ä»¶...`);
            
            // å¼€å§‹å¤„ç†é˜Ÿåˆ—
            while (concurrentDecryptCount < MAX_CONCURRENT_DECRYPT && decryptQueue.length > 0) {
                const file = decryptQueue.shift();
                decryptSingleFile(file);
            }
        }
        
        // æ¸…ç©ºå¹³å°è§£å¯†åˆ—è¡¨
        function clearPlatformDecryptedList() {
            platformDecryptedFiles = [];
            updatePlatformDecryptedList();
            showPlatformMessage('è§£å¯†åˆ—è¡¨å·²æ¸…ç©º', 'success');
        }
        
        // å¯†é’¥ç®¡ç†åŠŸèƒ½
        // æ ¹å¯†é’¥å­˜å‚¨é”®å
        const KEY_STORAGE_KEY = 'audioEncryptorRootKeys';
        
        // åŠ è½½å¯†é’¥åˆ—è¡¨ï¼ˆä»æ ¹å¯†é’¥å‚¨å­˜åº“ï¼‰
        function loadKeys() {
            try {
                const keysJson = localStorage.getItem(KEY_STORAGE_KEY);
                if (keysJson) {
                    const keys = JSON.parse(keysJson);
                    // ç¡®ä¿è¿”å›çš„æ˜¯æ•°ç»„
                    return Array.isArray(keys) ? keys : [];
                }
                return [];
            } catch (error) {
                console.error('åŠ è½½å¯†é’¥å¤±è´¥:', error);
                return [];
            }
        }
        
        // ä¿å­˜å¯†é’¥åˆ—è¡¨ï¼ˆåˆ°æ ¹å¯†é’¥å‚¨å­˜åº“ï¼‰
        function saveKeys(keys) {
            try {
                // ç¡®ä¿keysæ˜¯æ•°ç»„
                const keysToSave = Array.isArray(keys) ? keys : [];
                localStorage.setItem(KEY_STORAGE_KEY, JSON.stringify(keysToSave));
            } catch (error) {
                console.error('ä¿å­˜å¯†é’¥å¤±è´¥:', error);
            }
        }
        
        // æ˜¾ç¤ºå¯†é’¥åˆ—è¡¨
        function displayKeys() {
            const keys = loadKeys();
            const keyListElement = document.getElementById('key-list');
            
            if (!keyListElement) {
                console.error('æœªæ‰¾åˆ°key-listå…ƒç´ ');
                return;
            }
            
            if (keys.length === 0) {
                keyListElement.innerHTML = '<p>æš‚æ— å¯†é’¥ï¼Œç‚¹å‡»"æ·»åŠ å¯†é’¥"æˆ–"é‡æ–°ç”Ÿæˆ5ä¸ªå¯†é’¥"æ·»åŠ å¯†é’¥</p>';
                return;
            }
            
            // ä¼˜åŒ–å¯†é’¥æ˜¾ç¤ºï¼Œæ·»åŠ å¤åˆ¶åŠŸèƒ½
            keyListElement.innerHTML = keys.map((key, index) => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; margin-bottom: 8px; background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 6px;">
                    <div style="flex: 1;">
                        <div style="font-family: monospace; font-size: 14px; word-break: break-all; margin-bottom: 4px; color: #333; background: white; padding: 8px; border-radius: 4px; border: 1px solid #dee2e6; box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);">${key}</div>
                        <div style="font-size: 12px; color: #666;">å¯†é’¥ ${index + 1} / ${keys.length}</div>
                    </div>
                    <div style="display: flex; gap: 5px; flex-shrink: 0;">
                        <button onclick="copyKey('${key}')" style="padding: 6px 12px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; transition: background-color 0.2s;">å¤åˆ¶</button>
                        <button onclick="removeKey(${index})" style="padding: 6px 12px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; transition: background-color 0.2s;">åˆ é™¤</button>
                    </div>
                </div>
            `).join('');
        }
        
        // å¤åˆ¶å¯†é’¥åˆ°å‰ªè´´æ¿
        function copyKey(key) {
            navigator.clipboard.writeText(key)
                .then(() => {
                    showMessage('å¯†é’¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
                })
                .catch(err => {
                    console.error('å¤åˆ¶å¯†é’¥å¤±è´¥:', err);
                    showMessage('å¤åˆ¶å¯†é’¥å¤±è´¥', 'error');
                });
        }
        
        // æ·»åŠ å¯†é’¥
        function addKey() {
            const newKey = document.getElementById('new-key-input').value;
            if (!newKey) {
                showMessage('è¯·è¾“å…¥å¯†é’¥', 'error');
                return;
            }
            
            // éªŒè¯å¯†é’¥æ ¼å¼
            if (!/^[0-9a-fA-F]{32}$/.test(newKey)) {
                showMessage('å¯†é’¥æ ¼å¼é”™è¯¯ï¼Œå¿…é¡»ä¸º32ä½åå…­è¿›åˆ¶å­—ç¬¦', 'error');
                return;
            }
            
            const keys = loadKeys();
            
            // æ£€æŸ¥å¯†é’¥æ˜¯å¦å·²å­˜åœ¨
            if (keys.includes(newKey)) {
                showMessage('è¯¥å¯†é’¥å·²å­˜åœ¨', 'error');
                return;
            }
            
            // æ£€æŸ¥å¯†é’¥æ•°é‡æ˜¯å¦å·²è¾¾ä¸Šé™
            if (keys.length >= 50) {
                showMessage('å¯†é’¥æ•°é‡å·²è¾¾ä¸Šé™ï¼ˆ50ä¸ªï¼‰', 'error');
                return;
            }
            
            // æ·»åŠ å¯†é’¥
            keys.push(newKey);
            saveKeys(keys);
            displayKeys();
            
            // æ¸…ç©ºè¾“å…¥æ¡†
            document.getElementById('new-key-input').value = '';
            
            showMessage('å¯†é’¥æ·»åŠ æˆåŠŸ', 'success');
        }
        
        // åˆ é™¤å¯†é’¥
        function removeKey(index) {
            const keys = loadKeys();
            keys.splice(index, 1);
            saveKeys(keys);
            displayKeys();
            showMessage('å¯†é’¥åˆ é™¤æˆåŠŸ', 'success');
        }
        
        // é‡æ–°ç”Ÿæˆ5ä¸ªå¯†é’¥
        async function regenerateAllKeys() {
            const keys = [];
            
            for (let i = 0; i < 5; i++) {
                // ç”Ÿæˆéšæœº32ä½åå…­è¿›åˆ¶å¯†é’¥
                const randomBytes = crypto.getRandomValues(new Uint8Array(16));
                const key = Array.from(randomBytes).map(b => b.toString(16).padStart(2, '0')).join('');
                keys.push(key);
            }
            
            // ä¿å­˜å¯†é’¥
            const existingKeys = loadKeys();
            const newKeys = [...existingKeys, ...keys].slice(0, 50); // æœ€å¤šä¿ç•™50ä¸ªå¯†é’¥
            saveKeys(newKeys);
            displayKeys();
            
            showMessage(`æˆåŠŸç”Ÿæˆ ${keys.length} ä¸ªæ–°å¯†é’¥`, 'success');
        }
        
        // ä¸€é”®ä¿å­˜å½“å‰å¯†é’¥
        function saveCurrentKey() {
            if (!currentKey) {
                showMessage('è¯·å…ˆç”Ÿæˆå¯†é’¥', 'error');
                return;
            }
            
            const keys = loadKeys();
            
            // æ£€æŸ¥å¯†é’¥æ˜¯å¦å·²å­˜åœ¨
            if (keys.includes(currentKey)) {
                showMessage('å½“å‰å¯†é’¥å·²å­˜åœ¨', 'error');
                return;
            }
            
            // æ£€æŸ¥å¯†é’¥æ•°é‡æ˜¯å¦å·²è¾¾ä¸Šé™
            if (keys.length >= 50) {
                showMessage('å¯†é’¥æ•°é‡å·²è¾¾ä¸Šé™ï¼ˆ50ä¸ªï¼‰', 'error');
                return;
            }
            
            // æ·»åŠ å½“å‰å¯†é’¥
            keys.push(currentKey);
            saveKeys(keys);
            displayKeys();
            
            showMessage('å½“å‰å¯†é’¥ä¿å­˜æˆåŠŸ', 'success');
        }
        
        // è‡ªåŠ¨åŒ¹é…å¯†é’¥å¹¶è§£å¯†
        async function autoMatchKeyAndDecrypt(file, arrayBuffer) {
            const keys = loadKeys();
            if (keys.length === 0) {
                throw new Error('æ²¡æœ‰å¯ç”¨çš„å¯†é’¥');
            }
            
            // å°è¯•ä½¿ç”¨æ¯ä¸ªå¯†é’¥è§£å¯†
            for (const key of keys) {
                try {
                    const decryptedData = await decryptData(arrayBuffer, key);
                    return {
                        decryptedData: decryptedData,
                        key: key
                    };
                } catch (error) {
                    // å¯†é’¥ä¸åŒ¹é…ï¼Œç»§ç»­å°è¯•ä¸‹ä¸€ä¸ª
                    continue;
                }
            }
            
            throw new Error('æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„å¯†é’¥');
        }
        
        // é¡µé¢åŠ è½½æ—¶æ˜¾ç¤ºå¯†é’¥åˆ—è¡¨
        window.addEventListener('DOMContentLoaded', displayKeys);
        
        // éŸ³é¢‘æ’­æ”¾å™¨æ—¶é—´æ›´æ–°
        const audioPlayer = document.getElementById('audio-player');
        const currentTimeElement = document.getElementById('current-time');
        const totalTimeElement = document.getElementById('total-time');
        const progressFillElement = document.getElementById('progress-fill');
        const playBtn = document.getElementById('advanced-play-btn');
        const decryptStatusElement = document.getElementById('decrypt-status-advanced');
        
        // æ ¼å¼åŒ–æ—¶é—´ä¸º mm:ss æ ¼å¼
        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // æ›´æ–°æ’­æ”¾è¿›åº¦å’Œæ—¶é—´
        function updatePlayerProgress() {
            if (!audioPlayer.duration) return;
            
            // æ›´æ–°å½“å‰æ—¶é—´
            const currentTime = audioPlayer.currentTime;
            const duration = audioPlayer.duration;
            
            currentTimeElement.textContent = formatTime(currentTime);
            totalTimeElement.textContent = formatTime(duration);
            
            // æ›´æ–°è¿›åº¦æ¡
            const progress = (currentTime / duration) * 100;
            progressFillElement.style.width = `${progress}%`;
        }
        
        // æ›´æ–°æ’­æ”¾æŒ‰é’®çŠ¶æ€
        function updatePlayButton() {
            if (audioPlayer.paused) {
                playBtn.innerHTML = 'â–¶ï¸';
            } else {
                playBtn.innerHTML = 'â¸ï¸';
            }
        }
        
        // æ˜¾ç¤ºæ’­æ”¾çŠ¶æ€
        function showPlayStatus(status) {
            // æ›´æ–°è§£å¯†çŠ¶æ€å…ƒç´ ï¼ŒåŒæ—¶æ˜¾ç¤ºæ’­æ”¾çŠ¶æ€
            let statusText = '';
            if (status === 'loading') {
                statusText = 'ğŸ”„ åŠ è½½ä¸­...';
            } else if (status === 'encrypting') {
                statusText = 'ğŸ”’ åŠ å¯†ä¸­...';
            } else if (status === 'decrypting') {
                statusText = 'ğŸ”“ è§£å¯†ä¸­...';
            } else if (status === 'playing') {
                statusText = 'â–¶ï¸ æ’­æ”¾ä¸­';
            } else if (status === 'paused') {
                statusText = 'â¸ï¸ å·²æš‚åœ';
            } else if (status === 'ended') {
                statusText = 'â¹ï¸ æ’­æ”¾ç»“æŸ';
            } else if (status === 'ready') {
                statusText = 'âœ… å‡†å¤‡å°±ç»ª';
            }
            
            if (decryptStatusElement) {
                decryptStatusElement.textContent = statusText;
            }
        }
        
        // ç›‘å¬éŸ³é¢‘å…ƒæ•°æ®åŠ è½½å®Œæˆäº‹ä»¶ï¼Œæ›´æ–°æ€»æ—¶é•¿
        audioPlayer.addEventListener('loadedmetadata', () => {
            totalTimeElement.textContent = formatTime(audioPlayer.duration);
            showPlayStatus('ready');
        });
        
        // ç›‘å¬æ’­æ”¾æ—¶é—´æ›´æ–°äº‹ä»¶ï¼Œæ›´æ–°å½“å‰æ—¶é—´å’Œè¿›åº¦æ¡
        audioPlayer.addEventListener('timeupdate', updatePlayerProgress);
        
        // ç›‘å¬æ’­æ”¾å¼€å§‹äº‹ä»¶
        audioPlayer.addEventListener('play', () => {
            updatePlayerProgress();
            updatePlayButton();
            showPlayStatus('playing');
        });
        
        // ç›‘å¬æš‚åœäº‹ä»¶
        audioPlayer.addEventListener('pause', () => {
            updatePlayButton();
            showPlayStatus('paused');
        });
        
        // ç›‘å¬æ’­æ”¾ç»“æŸäº‹ä»¶
        audioPlayer.addEventListener('ended', () => {
            updatePlayButton();
            showPlayStatus('ended');
        });
        
        // ç›‘å¬åŠ è½½å¼€å§‹äº‹ä»¶
        audioPlayer.addEventListener('loadstart', () => {
            showPlayStatus('loading');
        });
        
        // ç›‘å¬åŠ è½½å®Œæˆäº‹ä»¶
        audioPlayer.addEventListener('canplay', () => {
            showPlayStatus('ready');
        });
        
        // åˆå§‹åŒ–æ—¶è®¾ç½®æ’­æ”¾çŠ¶æ€
        showPlayStatus('ready');
        
        // æ‰‹åŠ¨æ‰«æå¯¼å…¥
        async function manualScan() {
            showMessage('æ‰‹åŠ¨æ‰«æå¯¼å…¥åŠŸèƒ½å¼€å‘ä¸­ï¼Œæ•¬è¯·æœŸå¾…', 'info');
        }
        
        // ä¸Šä¼ æ–‡ä»¶å¤¹å¯¼å…¥
        async function uploadFolder() {
            showMessage('ä¸Šä¼ æ–‡ä»¶å¤¹å¯¼å…¥åŠŸèƒ½å¼€å‘ä¸­ï¼Œæ•¬è¯·æœŸå¾…', 'info');
        }
        
        // æ’­æ”¾å…¨éƒ¨æ­Œæ›²
        async function playAllSongs() {
            showMessage('æ’­æ”¾å…¨éƒ¨æ­Œæ›²åŠŸèƒ½å¼€å‘ä¸­ï¼Œæ•¬è¯·æœŸå¾…', 'info');
        }
        
        // æ¸…ç©ºæ­Œæ›²åˆ—è¡¨
        function clearSongList() {
            document.getElementById('song-library').innerHTML = '<p>æš‚æ— æ­Œæ›²ï¼Œç‚¹å‡»"æ‰‹åŠ¨æ‰«æå¯¼å…¥"æˆ–"ä¸Šä¼ æ–‡ä»¶å¤¹å¯¼å…¥"æ·»åŠ æ­Œæ›²</p>';
        }
    </script>
</body>
</html>